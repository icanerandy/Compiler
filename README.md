# Compiler
icanerandy's Compiler Project

## 词法分析

## 语法分析
## 语法制导
- 给每条产生式规则附加一个语义动作（一条代码片段）
  - 语义动作在产生式“**归约**”时执行
  - 即由**右部**的值计算**左部**的值
  - 以自底向上的计数为例进行讨论（自顶向下的技术与此类似）
```cpp
if (action[s, t] == "ri")
  ai  // 语义动作
  pop(βi)
  state s' = stack[top]
  push (X)
  push (goto[s', X])
```
在分析栈上维护三元组：<symbol, value, state>
其中**symbol**是终结符或非终结符，**value**是symbol所拥有的值，**state**是当前的分析状态
### 抽象语法树
#### LR分析中生成抽象语法树
- 在语法动作中，加入生成语法树的代码片段
  - 片段一般是语法树的“构造函数”
- 在产生式归约的时候，会自底向上构造整棵树
  - 从叶子到根
#### 源代码信息的保留和传播
- 抽象语法树是编译器前端和后端的接口
  - 程序一旦被转换成抽象语法树，则源代码即被丢弃
  - 后续的阶段只处理抽象语法树
- 所以抽象语法树必须编码足够多的源代码信息
  - 例如，它必须编码每个语法结构在源代码中的位置（文件、行号、列号等）
    - 这样，后续的检查阶段才能精确的报错
    - 或者获取程序的执行剖面
- 抽象语法树必须仔细设计！
## 语义分析
### 类型检查
- 对给定的一个表达式e，写一个check(e)函数
  - 返回表达式e的类型
  - 若类型不合法，则报错
### 变量声明的处理
- 查找符号表
### 语句的处理

#### 符号表
- 用来存储程序中的变量相关信息
  - **类型**
  - 作用域
  - 访问控制信息
  - ...
- 必须非常高效
  - 程序中的变量规模会很大
